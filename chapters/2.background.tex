%----------------------------------------------------------------------------------------
%	Background
%----------------------------------------------------------------------------------------
\chapter{Background}\label{chap:background}
\lhead{\emph{Background}} % Set the left side page header to "Introduction"

This work is about test orchestration strategies for regression testing.
Both concepts are widely studied within the software engineering.
In this chapter we provide a brief introduction to both, focusing on the challenges that will be tackled by this research.

\input{chapters/2.1.summary.tex}

\section{Regression Testing}\label{sec:regression}
Regression testing is the part of software testing concerned with testing previously existing components of a system to guarantee that recent changes in the codebase did not affect the originally specified functionality of components.
This process is often one of the costliest aspects of software development \cite{rothermel_improving_2018}, as it should ideally be performed every time a code change is committed, and involves much repetition of previously performed tests.

Regression testing is defined in \cite{minhas_regression_2017} as ``an activity which makes sure that everything is working correctly after changes to the system.''
That is, its primary objective is to assure that, after each change to the software, previously existing code continues to comply to specification (or simply to expectations, in case no formal specification exists).

The challenge of regression testing is aggravated in the relatively modern context of continuously evolving software.
While previously, a full regression test could be performed only occasionally, before the delivery date of a software, now it is important that regression tests are performed continuously, much like the software itself is developed.
This is not a problem in small projects, where it takes only a few seconds to run a test suite, but can be a big issue in large-scale software because of two factors: the test suite might be large and take a long time to execute, or code commits arrive at such a high frequency that there isn't enough time to run the test suite between each commit.
Often, a combination of both factors become a major challenge in large-scale software development \cite{memon_taming_2017}.

In this work, we are interested in regression testing in industrial settings.
We use ``industrial setting'' as a general term for large-scale software in the real world.
In practice, it can mean several different kinds of software, such as software developed as the primary product of a corporation (in the technology industry), software that provides essential features to other products (such as in the automotive or aircraft industry), or open-source software that is developed by a community instead of a team within a company.

\section{Test Suite Orchestration}\label{sec:orchestration}
Test orchestration is the art of generating, choosing, prioritizing and executing tests in order to maximize the effectiveness of testing while keeping costs within a desired budget.
Today, research on test orchestration is quite granular, with individual researchers focusing on specific challenges within this topic.
While this is important for the continuity of research, it fails in addressing the practical concerns of software developers, who desire a complete solution to aid the development cycle.

Features such as \textit{test generation}, \textit{test prioritization}, handling of \textit{flaky tests}, \textit{mutation testing}, \textit{test suite augmentation} and others can be considered under the broader scope of test orchestration.
While improvements in each of these features can provide substantial benefits, it is their combination that can produce the desired solution.

In general, test orchestration can be thought of as a broad challenge, formed by several sub-challenges.
These sub-challenges include, but are not limited, to the following:
\begin{itemize}
	\item \textbf{Test case selection:} the challenge of determining a sub-set of tests that, when executed, provide high-enough confidence that recent changes have not introduced failures in the software, while substantially reducing the execution costs.
	\item \textbf{Test case prioritization:} the challenge of ordering tests to detect as many potential faults within a given time or cost budget, emphasizing tests that are most likely to reveal faults or that cover critical parts of the program.
	\item \textbf{Test suite reduction or minimization:} the challenge of reducing the test suite by finding and removing redundant tests. This is similar to test case selection, but agnostic to changes in the code.
	\item \textbf{Test uncertainty:} the challenge of considering uncertain factors in software development, such as human input, values generated by machine learning, or cyber-physical interactions. In \cite{garlan_software_2010}, the sources, implications and challenges of uncertainty in software engineering are explored.
	\item \textbf{Test suite amplification or augmentation:} the challenge of expanding and improving an existing test suite through various different means. A survey on test suite amplification is found in \cite{danglot_snowballing_2019}; out of the categories presented, the synthesis of new tests with respect to changes is the most relevant for a continuously-evolving system. 
	\item \textbf{Compositional testing:} the challenge of guaranteeing correctness of a whole system by individually testing its distinct components. This challenge is mentioned in \cite{harman_start-ups_2018}, where the authors suggest the need of mock functions and analysis that can ``begin anywhere''.
	\item \textbf{Incremental testing:} the challenge of testing new parts of a software without necessarily having to re-test the whole software. In \cite{harman_start-ups_2018} and \cite{ohearn_continuous_2018}, the notion of using procedure summaries as a way of handling incrementality is mentioned. This way, it is possible to use previous executions of the test suite to accelerate its execution in the future when only small parts of code are added or changed.
\end{itemize}

Individually, each of these challenges can be its own field of research, and indeed many works have been published on them.
However, an ideal test orchestration solution should consider all or most of these challenges in unison, as solving each one alone is not sufficient to solve the problems faced by software developers in practice.

\subsection{Test Case Prioritization}\label{sec:tcp}

Another challenge of regression testing is to detect failing tests fast.
The objective of \tcp is to re-order test cases according to some definition of priority, in order to get faster feedback from the test execution.
A prioritized test suite still contains all test cases, 
so there is no loss of failures detection ability (assuming that test results are independent) -- what changes is the amount of time that it takes for one or more failures to be detected.
\tcp can be described as a function $P(T)$ that provides a permutation of $T$.
Some criteria often used for \tcp include similarity-based, coverage-based, and history-based~\cite{khatibsyarbini_test_2018}.


\subsection{Test Case Selection}\label{sec:tcs}

In regression testing, not all tests are relevant to a particular code change:
if only a small part of one file was updated, it is unlikely that the entire project would be affected and the full regression test suite would have to be run.
\tcs addresses the challenge of selecting a subset of tests that is representative of the entire suite in a given situation~\cite{YooHarman10RegressionTestingSurvey, RothermelHarrold94FrameworkForEvaluationRTS}.
In other words, given a test suite $T$, 
\tcs can be described as a function $S(T)$ that selects a subset of $T$ to be used for testing the current version of the system under test.
We say that a \tcs technique is \emph{safe} if it guarantees that all tests whose outcome may be affected by a change are included in the selected subset~\cite{RothermelHarrold94FrameworkForEvaluationRTS}. 
Common approaches for \tcs are change-based, history-based, and model-based~\cite{kazmi_effective_2017}.

\subsection{Test Case Reduction and Minimization}\label{sec:tsr}

\subsection{Test Case Amplification and Augmentation}\label{sec:tsa}
