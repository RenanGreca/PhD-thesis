\section{Test Suite Orchestration}\label{sec:orchestration}
Test orchestration is the art of generating, choosing, prioritizing and executing tests in order to maximize the effectiveness of testing while keeping costs within a desired budget.
Today, research on test orchestration is quite granular, with individual researchers focusing on specific challenges within this topic.
While this is important for the continuity of research, it fails in addressing the practical concerns of software developers, who desire a complete solution to aid the development cycle.

Features such as \textit{test generation}, \textit{test prioritization}, handling of \textit{flaky tests}, \textit{mutation testing}, \textit{test suite augmentation} and others can be considered under the broader scope of test orchestration.
While improvements in each of these features can provide substantial benefits, it is their combination that can produce the desired solution.

In general, test orchestration can be thought of as a broad challenge, formed by several sub-challenges.
These sub-challenges include, but are not limited, to the following:
\begin{itemize}
	\item \textbf{Test case selection:} the challenge of determining a sub-set of tests that, when executed, provide high-enough confidence that recent changes have not introduced failures in the software, while substantially reducing the execution costs.
	\item \textbf{Test case prioritization:} the challenge of ordering tests to detect as many potential faults within a given time or cost budget, emphasizing tests that are most likely to reveal faults or that cover critical parts of the program.
	\item \textbf{Test suite reduction or minimization:} the challenge of reducing the test suite by finding and removing redundant tests. This is similar to test case selection, but agnostic to changes in the code.
	\item \textbf{Test uncertainty:} the challenge of considering uncertain factors in software development, such as human input, values generated by machine learning, or cyber-physical interactions. In \cite{garlan_software_2010}, the sources, implications and challenges of uncertainty in software engineering are explored.
	\item \textbf{Test suite amplification or augmentation:} the challenge of expanding and improving an existing test suite through various different means. A survey on test suite amplification is found in \cite{danglot_snowballing_2019}; out of the categories presented, the synthesis of new tests with respect to changes is the most relevant for a continuously-evolving system. 
	\item \textbf{Compositional testing:} the challenge of guaranteeing correctness of a whole system by individually testing its distinct components. This challenge is mentioned in \cite{harman_start-ups_2018}, where the authors suggest the need of mock functions and analysis that can ``begin anywhere''.
	\item \textbf{Incremental testing:} the challenge of testing new parts of a software without necessarily having to re-test the whole software. In \cite{harman_start-ups_2018} and \cite{ohearn_continuous_2018}, the notion of using procedure summaries as a way of handling incrementality is mentioned. This way, it is possible to use previous executions of the test suite to accelerate its execution in the future when only small parts of code are added or changed.
\end{itemize}

Individually, each of these challenges can be its own field of research, and indeed many works have been published on them.
However, an ideal test orchestration solution should consider all or most of these challenges in unison, as solving each one alone is not sufficient to solve the problems faced by software developers in practice.

\subsection{Test Case Prioritization}\label{sec:tcp}

Another challenge of regression testing is to detect failing tests fast.
The objective of \tcp is to re-order test cases according to some definition of priority, in order to get faster feedback from the test execution.
A prioritized test suite still contains all test cases, 
so there is no loss of failures detection ability (assuming that test results are independent) -- what changes is the amount of time that it takes for one or more failures to be detected.
\tcp can be described as a function $P(T)$ that provides a permutation of $T$.
Some criteria often used for \tcp include similarity-based, coverage-based, and history-based~\cite{khatibsyarbini_test_2018}.


\subsection{Test Case Selection}\label{sec:tcs}

In regression testing, not all tests are relevant to a particular code change:
if only a small part of one file was updated, it is unlikely that the entire project would be affected and the full regression test suite would have to be run.
\tcs addresses the challenge of selecting a subset of tests that is representative of the entire suite in a given situation~\cite{YooHarman10RegressionTestingSurvey, RothermelHarrold94FrameworkForEvaluationRTS}.
In other words, given a test suite $T$, 
\tcs can be described as a function $S(T)$ that selects a subset of $T$ to be used for testing the current version of the system under test.
We say that a \tcs technique is \emph{safe} if it guarantees that all tests whose outcome may be affected by a change are included in the selected subset~\cite{RothermelHarrold94FrameworkForEvaluationRTS}. 
Common approaches for \tcs are change-based, history-based, and model-based~\cite{kazmi_effective_2017}.

\subsection{Test Case Reduction and Minimization}\label{sec:tsr}

\subsection{Test Case Amplification and Augmentation}\label{sec:tsa}
