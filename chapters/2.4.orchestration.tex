\section{Test Suite Orchestration}\label{sec:orchestration}

Given the challenges associated with ever-expanding regression testing suites of continuously evolving software, we 
\textit{Test suite orchestration} is the art of generating, choosing, prioritizing and executing tests in order to maximize the effectiveness of testing while keeping costs within a desired budget.
Today, research on test orchestration is quite granular, with individual researchers mostly focusing on specific challenges within this topic.
While this is important for the continuity and advancement of research, it fails in addressing the practical concerns of software developers, who desire a complete solution to aid the development cycle.

Features such as \textit{test case generation}, \textit{test case prioritization}, handling of \textit{flaky tests}, \textit{mutation testing}, \textit{test suite augmentation} and others can be considered under the broader scope of test orchestration.
While improvements in each of these features can provide substantial benefits, it is their combination that can produce the desired solution.

In general, test suite orchestration can be thought of as a broad challenge with the ultimate goal of improving regression testing in multiple aspects, composed of several sub-challenges.
These sub-challenges include, but are not limited, to the following:
\begin{itemize}
	\item \textbf{Test case selection (\tcs):} the challenge of determining a sub-set of tests that, when executed, provides sufficiently high confidence that recent changes have not introduced failures in the software, while substantially reducing the execution costs.
	\item \textbf{Test case prioritization (\tcp):} the challenge of ordering tests to detect potential faults as early as possible, prioritizing tests that are most likely to reveal faults or that cover critical parts of the program.
	\item \textbf{Test suite reduction or minimization (\tsr):} the challenge of reducing the test suite by finding and possibly removing redundant tests. Unlike \tcs, which is change-aware, \tsr.
	\item \textbf{Test suite amplification or augmentation:} the challenge of expanding and improving an existing test suite through various different means. A survey on test suite amplification is found in \cite{danglot_snowballing_2019}; out of the categories presented, the synthesis of new tests with respect to changes is the most relevant for a continuously-evolving system. 
	\item \textbf{Handling of unreliable/flaky tests:} a test that might pass or fail non-deterministically without changes to the SUT is designated as unreliable or flaky. This can happen due to poor test design, misconfiguration of the test suite or the testing environment, or timing errors in asynchronous tasks. These tests make it difficult for developers to identify true faults in the system and thus they should ideally be detected and flagged as such.
	\item \textbf{Test uncertainty:} the challenge of considering uncertain factors in software development, such as human input, values generated by machine learning, or cyber-physical interactions. In \cite{garlan_software_2010}, the sources, implications and challenges of uncertainty in software engineering are explored.
	\item \textbf{Compositional testing:} the challenge of guaranteeing correctness of a whole system by individually testing its distinct components. For example, a system using multi-component testing should be able to rely on the preceding single-component tests being correct. This challenge is mentioned in \cite{harman_start-ups_2018}, where the authors suggest the need of mock functions and analysis that can ``begin anywhere''.
	\item \textbf{Incremental testing:} the challenge of testing new parts of a software without necessarily having to re-test the whole software. In \cite{harman_start-ups_2018} and \cite{ohearn_continuous_2018}, the notion of using procedure summaries as a way of handling incrementality is mentioned. This way, it is possible to use previous executions of the test suite to accelerate its execution in the future when only small parts of code are added or changed.
\end{itemize}

Individually, each of these challenges can be its own field of research, and indeed many works have been published on them.
However, an ideal test orchestration solution should consider all or most of these challenges in unison, as solving each one alone is not sufficient to solve the problems faced by software developers in practice.

Due to the breadth of the orchestration challenge, for this thesis the decision was made to restrict the scope and focus primarily on four aspects: test case prioritization, test case selection, test suite reduction/minimization and test suite amplification/augmentation.
Other topics remain tangential to the research and may occasionally be part of the discussion, but are not the focus of this work.
The following subsection describes in more detail the four challenges that this study focuses on.

\subsection{Test Case Prioritization}
\label{sec:tcp}

Another challenge of regression testing is to detect failing tests fast.
The objective of \tcp is to re-order test cases according to some definition of priority, in order to get faster feedback from the test execution.
A prioritized test suite still contains all test cases, 
so there is no loss of failures detection ability (assuming that test results are independent) -- what changes is the amount of time that it takes for one or more failures to be detected.
\tcp can be described as a function $P(T)$ that provides a permutation of $T$.
Some criteria often used for \tcp include similarity-based, coverage-based, and history-based~\cite{khatibsyarbini_test_2018}.


\subsection{Test Case Selection}
\label{sec:tcs}

In regression testing, not all tests are relevant to a particular code change:
if only a small part of one file was updated, it is unlikely that the entire project would be affected and the full regression test suite would have to be run.
\tcs addresses the challenge of selecting a subset of tests that is representative of the entire suite in a given situation~\cite{YooHarman10RegressionTestingSurvey, RothermelHarrold94FrameworkForEvaluationRTS}.
In other words, given a test suite $T$, 
\tcs can be described as a function $S(T)$ that selects a subset of $T$ to be used for testing the current version of the system under test.
We say that a \tcs technique is \emph{safe} if it guarantees that all tests whose outcome may be affected by a change are included in the selected subset~\cite{RothermelHarrold94FrameworkForEvaluationRTS}. 
Common approaches for \tcs are change-based, history-based, and model-based~\cite{kazmi_effective_2017}.

\subsection{Test Case Reduction and Minimization}\label{sec:tsr}

\subsection{Test Case Amplification and Augmentation}\label{sec:tsa}
